/**
 * Copyright (c) 2024-2025 –¢–∞—Ä–∞–±–∞–Ω–æ–≤ –ê–ª–µ–∫—Å–∞–Ω–¥—Ä –í–∏–∫—Ç–æ—Ä–æ–≤–∏—á
 * All rights reserved.
 * 
 * This software is proprietary and confidential.
 * Unauthorized copying, modification, or distribution is prohibited.
 * 
 * For licensing inquiries: info@hb3-accelerator.com
 * Website: https://hb3-accelerator.com
 * GitHub: https://github.com/HB3-ACCELERATOR
 */

const db = require('../db');
const fs = require('fs');
const path = require('path');

class EncryptedDataService {
  constructor() {
    this.encryptionKey = this.loadEncryptionKey();
    this.isEncryptionEnabled = !!this.encryptionKey;
    
    if (this.isEncryptionEnabled) {
      // console.log('üîê –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ');
      // console.log('üìã –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫');
    } else {
      // console.log('‚ö†Ô∏è –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –æ—Ç–∫–ª—é—á–µ–Ω–æ - –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
  }

  loadEncryptionKey() {
    try {
      const keyPath = path.join(__dirname, '../../ssl/keys/full_db_encryption.key');
      // console.log(`[EncryptedDB] Trying key path: ${keyPath}`);
      if (fs.existsSync(keyPath)) {
        const key = fs.readFileSync(keyPath, 'utf8').trim();
        // console.log(`[EncryptedDB] Key loaded from: ${keyPath}, length: ${key.length}`);
        return key;
      }
      // –ü–æ–ø—Ä–æ–±—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ—Ä–Ω—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
      const altKeyPath = '/app/ssl/keys/full_db_encryption.key';
      // console.log(`[EncryptedDB] Trying alternative key path: ${altKeyPath}`);
      if (fs.existsSync(altKeyPath)) {
        const key = fs.readFileSync(altKeyPath, 'utf8').trim();
        // console.log(`[EncryptedDB] Key loaded from: ${altKeyPath}, length: ${key.length}`);
        return key;
      }
      // console.log(`[EncryptedDB] No key file found, using default key`);
      return 'default-key';
    } catch (error) {
      // console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–ª—é—á–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:', error);
      return 'default-key';
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π
   */
  async getData(tableName, conditions = {}, limit = null, orderBy = null) {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
      if (!this.isEncryptionEnabled) {
        return await this.executeUnencryptedQuery(tableName, conditions, limit, orderBy);
      }

      // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–æ–Ω–∫–∞—Ö
      const { rows: columns } = await db.getQuery()(`
        SELECT column_name, data_type 
        FROM information_schema.columns 
        WHERE table_name = $1 
        AND table_schema = 'public'
        ORDER BY ordinal_position
      `, [tableName]);

      // –°—Ç—Ä–æ–∏–º SELECT —Å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–æ–π
      const selectFields = columns.map(col => {
        if (col.column_name.endsWith('_encrypted')) {
          const originalName = col.column_name.replace('_encrypted', '');
          // console.log(`üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º –ø–æ–ª–µ ${col.column_name} -> ${originalName}`);
          if (col.data_type === 'jsonb') {
            return `decrypt_json(${col.column_name}, $1) as "${originalName}"`;
          } else {
            return `decrypt_text(${col.column_name}, $1) as "${originalName}"`;
          }
        } else if (!col.column_name.includes('_encrypted')) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —ç—Ç–æ–π –∫–æ–ª–æ–Ω–∫–∏
          const hasEncryptedVersion = columns.some(encCol => 
            encCol.column_name === `${col.column_name}_encrypted`
          );
          
          // –ï—Å–ª–∏ –µ—Å—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é
          if (hasEncryptedVersion) {
            // console.log(`‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–µ ${col.column_name} (–µ—Å—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)`);
            return null;
          }
          
          // –ó–∞–∫–ª—é—á–∞–µ–º –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –≤ –∫–∞–≤—ã—á–∫–∏
          const reservedWords = ['order', 'group', 'user', 'index', 'table', 'column', 'key', 'foreign', 'primary', 'unique', 'check', 'constraint', 'default', 'null', 'not', 'and', 'or', 'as', 'on', 'in', 'is', 'like', 'between', 'exists', 'all', 'any', 'some', 'distinct', 'case', 'when', 'then', 'else', 'end', 'limit', 'offset', 'having', 'union', 'intersect', 'except', 'with', 'recursive'];
          if (reservedWords.includes(col.column_name.toLowerCase())) {
            return `"${col.column_name}"`;
          }
          return col.column_name;
        }
        return null;
      }).filter(Boolean).join(', ');

      let query = `SELECT ${selectFields} FROM ${tableName}`;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—è –≤ —Ç–∞–±–ª–∏—Ü–µ
      const hasEncryptedFields = columns.some(col => col.column_name.endsWith('_encrypted'));
      const params = hasEncryptedFields ? [this.encryptionKey] : [];
      let paramIndex = hasEncryptedFields ? 2 : 1;
      
      // –°–ø–∏—Å–æ–∫ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–≤ –¥–ª—è WHERE-—É—Å–ª–æ–≤–∏–π
      const reservedWords = ['order', 'group', 'user', 'index', 'table', 'column', 'key', 'foreign', 'primary', 'unique', 'check', 'constraint', 'default', 'null', 'not', 'and', 'or', 'as', 'on', 'in', 'is', 'like', 'between', 'exists', 'all', 'any', 'some', 'distinct', 'case', 'when', 'then', 'else', 'end', 'limit', 'offset', 'having', 'union', 'intersect', 'except', 'with', 'recursive'];

      if (Object.keys(conditions).length > 0) {
        const whereClause = Object.keys(conditions)
          .map(key => {
            const value = conditions[key];
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∫–æ–ª–æ–Ω–∫–∏
            const encryptedColumn = columns.find(col => col.column_name === `${key}_encrypted`);
            
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä $in
            if (value && typeof value === 'object' && value.$in && Array.isArray(value.$in)) {
              const placeholders = value.$in.map(() => `$${paramIndex++}`).join(', ');
              const columnName = encryptedColumn ? key : 
                (reservedWords.includes(key.toLowerCase()) ? `"${key}"` : key);
              return `${columnName} IN (${placeholders})`;
            }
            
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ç–æ—Ä $ne
            if (value && typeof value === 'object' && value.$ne !== undefined) {
              const columnName = encryptedColumn ? key : 
                (reservedWords.includes(key.toLowerCase()) ? `"${key}"` : key);
              return `${columnName} != $${paramIndex++}`;
            }
            
            if (encryptedColumn) {
              // –î–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º
              return `${key}_encrypted = encrypt_text($${paramIndex++}, ${hasEncryptedFields ? '$1' : 'NULL'})`;
            } else {
              // –î–ª—è –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
              // –ó–∞–∫–ª—é—á–∞–µ–º –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –≤ –∫–∞–≤—ã—á–∫–∏
              const columnName = reservedWords.includes(key.toLowerCase()) ? `"${key}"` : key;
              return `${columnName} = $${paramIndex++}`;
            }
          })
          .join(' AND ');
        query += ` WHERE ${whereClause}`;
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è $in –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
        const paramsToAdd = Object.values(conditions).map(value => {
          if (value && typeof value === 'object' && value.$in && Array.isArray(value.$in)) {
            return value.$in;
          }
          if (value && typeof value === 'object' && value.$ne !== undefined) {
            return value.$ne;
          }
          return value;
        }).flat();
        
        params.push(...paramsToAdd);
      }

      if (orderBy) {
        query += ` ORDER BY ${orderBy}`;
      }

      if (limit) {
        query += ` LIMIT ${limit}`;
      }

      // console.log(`üîç [getData] –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å:`, query);
      // console.log(`üîç [getData] –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:`, params);
      
      const { rows } = await db.getQuery()(query, params);
      
              // console.log(`üìä –†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø—Ä–æ—Å–∞ –∏–∑ ${tableName}:`, rows);
      
      return rows;
    } catch (error) {
      // console.error(`‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ ${tableName}:`, error);
      throw error;
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Ç–∞–±–ª–∏—Ü—É —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º
   */
  async saveData(tableName, data, whereConditions = null) {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
      if (!this.isEncryptionEnabled) {
        return await this.executeUnencryptedSave(tableName, data, whereConditions);
      }
      
      // –î–ª—è —Ç–∞–±–ª–∏—Ü—ã users –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–º–µ—à–∞–Ω–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏
      if (tableName === 'users') {
        return await this.executeUnencryptedSave(tableName, data, whereConditions);
      }

      // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–æ–Ω–∫–∞—Ö
      const { rows: columns } = await db.getQuery()(`
        SELECT column_name, data_type 
        FROM information_schema.columns 
        WHERE table_name = $1 
        AND table_schema = 'public'
        ORDER BY ordinal_position
      `, [tableName]);

      // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
      const encryptedData = {};
      const unencryptedData = {};
      const filteredData = {}; // –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—è –≤ —Ç–∞–±–ª–∏—Ü–µ
      const hasEncryptedFields = columns.some(col => col.column_name.endsWith('_encrypted'));
      let paramIndex = hasEncryptedFields ? 2 : 1; // –ù–∞—á–∏–Ω–∞–µ–º —Å 2, –µ—Å–ª–∏ –µ—Å—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—è, –∏–Ω–∞—á–µ —Å 1
      
      for (const [key, value] of Object.entries(data)) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∫–æ–ª–æ–Ω–∫–∏
        const encryptedColumn = columns.find(col => col.column_name === `${key}_encrypted`);
        const unencryptedColumn = columns.find(col => col.column_name === key);
        
        // console.log(`üîç –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª–µ ${key} = "${value}" (—Ç–∏–ø: ${typeof value})`);
        
        if (encryptedColumn) {
          // –ï—Å–ª–∏ –µ—Å—Ç—å –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞, —à–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø—É—Å—Ç–æ–µ –ø–µ—Ä–µ–¥ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ–º
          if (value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) {
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            // console.log(`‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç–æ–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–µ ${key}`);
            continue;
          }
          const currentParamIndex = paramIndex++;
          filteredData[key] = value; // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
          // console.log(`‚úÖ –î–æ–±–∞–≤–∏–ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–µ ${key} –≤ filteredData`);
          if (encryptedColumn.data_type === 'jsonb') {
            encryptedData[`${key}_encrypted`] = `encrypt_json($${currentParamIndex}, ${hasEncryptedFields ? '$1::text' : 'NULL'})`;
          } else {
            encryptedData[`${key}_encrypted`] = `encrypt_text($${currentParamIndex}, ${hasEncryptedFields ? '$1::text' : 'NULL'})`;
          }
        } else if (unencryptedColumn) {
          // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–ª–æ–Ω–∫–∞, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø—É—Å—Ç–æ–µ –ø–µ—Ä–µ–¥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º (–∫—Ä–æ–º–µ role –∏ sender_type)
          if ((value === null || value === undefined || (typeof value === 'string' && value.trim() === '')) && 
              key !== 'role' && key !== 'sender_type') {
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∫—Ä–æ–º–µ role –∏ sender_type
            // console.log(`‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç–æ–µ –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–µ ${key}`);
            continue;
          }
          filteredData[key] = value; // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
          unencryptedData[key] = `$${paramIndex++}`;
          // console.log(`‚úÖ –î–æ–±–∞–≤–∏–ª–∏ –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª–µ ${key} –≤ filteredData –∏ unencryptedData`);
        } else {
          // –ï—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
          // console.warn(`‚ö†Ô∏è –ö–æ–ª–æ–Ω–∫–∞ ${key} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ ${tableName}`);
        }
      }

      const allData = { ...unencryptedData, ...encryptedData };
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
      if (Object.keys(allData).length === 0) {
        // console.warn(`‚ö†Ô∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ —Ç–∞–±–ª–∏—Ü–µ ${tableName} - –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø—É—Å—Ç—ã–µ`);
        // console.warn(`‚ö†Ô∏è –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:`, data);
        // console.warn(`‚ö†Ô∏è –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:`, filteredData);
        return null;
      }
      
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–∫–ª—é—á–µ–Ω–∏—è –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–≤ –≤ –∫–∞–≤—ã—á–∫–∏
      const quoteReservedWord = (word) => {
        const reservedWords = ['order', 'group', 'user', 'index', 'table', 'column', 'key', 'foreign', 'primary', 'unique', 'check', 'constraint', 'default', 'null', 'not', 'and', 'or', 'as', 'on', 'in', 'is', 'like', 'between', 'exists', 'all', 'any', 'some', 'distinct', 'case', 'when', 'then', 'else', 'end', 'limit', 'offset', 'having', 'union', 'intersect', 'except', 'with', 'recursive'];
        return reservedWords.includes(word.toLowerCase()) ? `"${word}"` : word;
      };
      
      if (whereConditions) {
        // UPDATE
        const setClause = Object.keys(allData)
          .map((key, index) => `${quoteReservedWord(key)} = ${allData[key]}`)
          .join(', ');
        const whereClause = Object.keys(whereConditions)
          .map((key, index) => `${quoteReservedWord(key)} = $${paramIndex + index}`)
          .join(' AND ');

        const query = `UPDATE ${tableName} SET ${setClause} WHERE ${whereClause} RETURNING *`;
        const allParams = hasEncryptedFields ? [this.encryptionKey, ...Object.values(filteredData), ...Object.values(whereConditions)] : [...Object.values(filteredData), ...Object.values(whereConditions)];

        const { rows } = await db.getQuery()(query, allParams);
        return rows[0];
      } else {
        // INSERT
        const columns = Object.keys(allData).map(key => quoteReservedWord(key));
        const placeholders = Object.keys(allData).map(key => allData[key]).join(', ');

        const query = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) RETURNING *`;
        const params = hasEncryptedFields ? [this.encryptionKey, ...Object.values(filteredData)] : [...Object.values(filteredData)];

        const { rows } = await db.getQuery()(query, params);
        return rows[0];
      }
    } catch (error) {
      // console.error(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –≤ ${tableName}:`, error);
      throw error;
    }
  }

  /**
   * –£–¥–∞–ª–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
   */
  async deleteData(tableName, conditions) {
    try {
      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–∫–ª—é—á–µ–Ω–∏—è –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–ª–æ–≤ –≤ –∫–∞–≤—ã—á–∫–∏
      const quoteReservedWord = (word) => {
        const reservedWords = ['order', 'group', 'user', 'index', 'table', 'column', 'key', 'foreign', 'primary', 'unique', 'check', 'constraint', 'default', 'null', 'not', 'and', 'or', 'as', 'on', 'in', 'is', 'like', 'between', 'exists', 'all', 'any', 'some', 'distinct', 'case', 'when', 'then', 'else', 'end', 'limit', 'offset', 'having', 'union', 'intersect', 'except', 'with', 'recursive'];
        return reservedWords.includes(word.toLowerCase()) ? `"${word}"` : word;
      };

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
      if (!this.isEncryptionEnabled) {
        let query = `DELETE FROM ${tableName}`;
        const params = [];
        let paramIndex = 1;

        if (Object.keys(conditions).length > 0) {
          const whereClause = Object.keys(conditions)
            .map(key => `${quoteReservedWord(key)} = $${paramIndex++}`)
            .join(' AND ');
          query += ` WHERE ${whereClause}`;
          params.push(...Object.values(conditions));
        }

        const { rows } = await db.getQuery()(query, params);
        return rows;
      }

      // –î–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü - –ø–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π DELETE
      // TODO: –î–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π WHERE
      let query = `DELETE FROM ${tableName}`;
      const params = [];
      let paramIndex = 1;

      if (Object.keys(conditions).length > 0) {
        const whereClause = Object.keys(conditions)
          .map(key => `${quoteReservedWord(key)} = $${paramIndex++}`)
          .join(' AND ');
        query += ` WHERE ${whereClause}`;
        params.push(...Object.values(conditions));
      }

      const result = await db.getQuery()(query, params);
      return result.rows;
    } catch (error) {
      // console.error(`‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ ${tableName}:`, error);
      throw error;
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
   */
  getEncryptionStatus() {
      return {
      enabled: this.isEncryptionEnabled,
      keyExists: !!this.encryptionKey,
      keyPath: path.join(__dirname, '../../ssl/keys/full_db_encryption.key')
    };
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ —à–∏—Ñ—Ä–æ–≤–∞—Ç—å –∫–æ–ª–æ–Ω–∫—É
   */
  shouldEncryptColumn(column) {
    const encryptableTypes = ['text', 'varchar', 'character varying', 'json', 'jsonb'];
    return encryptableTypes.includes(column.data_type) && 
           !column.column_name.includes('_encrypted') &&
           !['created_at', 'updated_at', 'id'].includes(column.column_name);
  }

  /**
   * –í—ã–ø–æ–ª–Ω–∏—Ç—å –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å (fallback)
   */
  async executeUnencryptedQuery(tableName, conditions = {}, limit = null, orderBy = null) {
    let query = `SELECT * FROM ${tableName}`;
    const params = [];
    let paramIndex = 1;

    if (Object.keys(conditions).length > 0) {
      const whereClause = Object.keys(conditions)
        .map(key => `${key} = $${paramIndex++}`)
        .join(' AND ');
      query += ` WHERE ${whereClause}`;
      params.push(...Object.values(conditions));
    }

    if (orderBy) {
      query += ` ORDER BY ${orderBy}`;
    }

    if (limit) {
      query += ` LIMIT ${limit}`;
    }

    const { rows } = await db.getQuery()(query, params);
    return rows;
  }

  /**
   * –í—ã–ø–æ–ª–Ω–∏—Ç—å –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ (fallback)
   */
  async executeUnencryptedSave(tableName, data, whereConditions = null) {
    if (whereConditions) {
      // UPDATE
      const setClause = Object.keys(data)
        .map((key, index) => `${key} = $${index + 1}`)
        .join(', ');
      const whereClause = Object.keys(whereConditions)
        .map((key, index) => `${key} = $${Object.keys(data).length + index + 1}`)
        .join(' AND ');

      const query = `UPDATE ${tableName} SET ${setClause} WHERE ${whereClause} RETURNING *`;
      const params = [...Object.values(data), ...Object.values(whereConditions)];

      const { rows } = await db.getQuery()(query, params);
      return rows[0];
    } else {
      // INSERT
      const columns = Object.keys(data);
      const values = Object.values(data);
      const placeholders = values.map((_, index) => `$${index + 1}`).join(', ');

      const query = `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders}) RETURNING *`;
      const { rows } = await db.getQuery()(query, values);
      return rows[0];
    }
  }
}

module.exports = new EncryptedDataService(); 